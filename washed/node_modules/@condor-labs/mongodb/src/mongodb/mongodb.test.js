'use strict';

const Joi = require('@hapi/joi');
const logger = require('@condor-labs/logger');
const sinon = require('sinon');
const { expect, use } = require('chai');
const queryString = require('query-string');

const helper = require('./index');

use(require('chai-as-promised'));

let settingsToValid = {
  url: 'mongodb://host:1234/database',
  host: 'hos,host2t',
  port: 1234,
  database: 'database',
  user: 'user',
  password: 'password',
  replicaSet: 'replicateSet',
  ssl: true,
  authSource: 'source'
};

describe(`Mongo helper`, () => {
  const mongoose = require('mongoose');
  mongoose.Promise = global.Promise;

  describe(`When setting the connection settings`, () => {
    it('should settings not be null', () => {
      sinon.stub(Joi, 'assert').returns({ error: null });
      sinon.stub(helper, '_validateSettings').returns(true);
      const setWithReadPref = JSON.parse(JSON.stringify(settingsToValid));
      setWithReadPref.readPreference = '';
      helper._setSettings(setWithReadPref);
      expect(helper._settings).to.not.equal(null);
      Joi.assert.restore();
      helper._validateSettings.restore();
    });
    it('should throw an error when settings are not valid', () => {
      sinon.stub(helper, '_validateSettings').returns(false);
      expect(helper._setSettings).to.throw(Error);
      helper._validateSettings.restore();
    });

    it('should settins ssl not valid', () => {
      const settings = { ...settingsToValid, ssl: '123' };
      sinon.stub(console, 'error');
      sinon.stub(helper, '_validateSettings').returns(false);
      expect(helper._setSettings.bind(helper, settings)).to.throw(Error);
      console.error.restore();
      helper._validateSettings.restore();
    });

    describe('When settings are validated', () => {
      describe('when a setting is invalid', () => {
        it('should _validateSettings will throw error', () => {
          sinon
            .stub(helper, '_deleteParamsFromSettings')
            .throws(new Error('Controlled error for testing'));
          settingsToValid.port = 'PORT';
          sinon.stub(logger, 'error');
          sinon.stub(Joi, 'assert').returns({ error: null });
          expect(
            helper._validateSettings.bind(helper, settingsToValid)
          ).to.throw();
          logger.error.restore();
          Joi.assert.restore();
          helper._deleteParamsFromSettings.restore();
        });

        it('should return false when settings are empty', () => {
          sinon.stub(logger, 'error');
          expect(helper._validateSettings(null)).to.be.false;
          logger.error.restore();
        });
      });

      describe('when setting are valid this for a sinlge connection', () => {
        it('should return true when setting are valid for one connection', () => {
          sinon.stub(helper, '_deleteParamsFromSettings').returns([]);
          sinon.stub(Joi, 'assert').returns({ error: null });
          expect(helper._validateSettings(settingsToValid)).to.be.true;
          helper._deleteParamsFromSettings.restore();
          Joi.assert.restore();
        });

        it('should return true when settings are valid for many connections', () => {
          sinon.stub(helper, '_deleteParamsFromSettings').returns([
            {
              connectionName: 'firstConnect',
              name: 'hola'
            },
            {
              connectionName: 'secondConnect',
              name: 'hola2'
            },
            {
              connectionName: 'thirdConnect',
              name: 'hola3'
            }
          ]);
          sinon.stub(Joi, 'assert').returns({ error: null });
          const set1 = JSON.parse(JSON.stringify(settingsToValid));
          const set2 = JSON.parse(JSON.stringify(settingsToValid));
          const connectionArray = [set1, set2];
          expect(helper._validateSettings(connectionArray)).to.be.true;
          helper._deleteParamsFromSettings.restore();
          Joi.assert.restore();
        });
      });
    });
  });

  describe('When connecting to the mongo database', () => {
    let mongooseMock;

    const connectionOptions = {
      user: settingsToValid.user,
      pass: settingsToValid.password,
      replicaSet: settingsToValid.replicaSet,
      ssl: true,
      authSource: settingsToValid.authSource,
      useNewUrlParser: true,
      useUnifiedTopology: true
    };

    it('should connect with default settings', async () => {
      sinon.stub(helper, '_hasMultipleConnection').value(false);
      sinon
        .stub(helper, '_connectSingleConnection')
        .returns({ connection: 'done' });
      sinon.stub(helper, '_isConnected').returns(true);
      let connection = await helper._connect();
      expect(connection).to.be.true;
      helper._isConnected.restore();
      helper._connectSingleConnection.restore();
    });

    it('should connect with many arguments', async () => {
      sinon.stub(helper, '_hasMultipleConnection').value(true);
      sinon
        .stub(helper, '_connectMultipleConnection')
        .returns({ connection: 'done' });
      sinon.stub(helper, '_isConnected').returns(true);
      let isConnected2 = await helper._connect('');
      expect(isConnected2).to.be.true;
      helper._isConnected.restore();
      helper._connectMultipleConnection.restore();
    });
  });
  // ----------------------------------------------------------------
  describe('when the connection is successfull', () => {
    let mongooseMock = sinon.mock(mongoose);
    it('should return false cuz there is not connection', async () => {
      sinon.stub(helper, '_clients').value({ TESTDB: {} });
      sinon.stub(helper, '_settings').value({ TESTDB: {} });
      expect(helper._isConnected('testDb')).to.be.false;
    });
    it('should return true cuz there are multiple connections', () => {
      sinon.stub(helper, '_hasMultipleConnection').value(true);
      sinon.stub(helper, '_settings').value({ TESTDB: {} });
      sinon.stub(helper, '_clients').value({ TESTDB: { _readyState: 1 } });
      expect(helper._isConnected('testDB')).to.be.true;
    });
    // PENDING
    it('should return true cuz there is a single connections', () => {
      sinon.stub(helper, '_clients').value({ TESTDB: { _readyState: 1 } });
      sinon.stub(helper, '_hasMultipleConnection').value(false);
      mongooseMock.object.connection.readyState = 1;
      expect(helper._isConnected('testDB')).to.be.true;
    });
    // PENDING
    it('should return client connected', () => {
      sinon.stub(helper, '_isConnected').returns(false);
      sinon.stub(helper, '_clients').returns({});
      sinon.stub(helper, '_setSettings').callsFake(() => {
        helper._settings = {
          connect1: {
            name: 'connection for test',
            isConnected: true
          }
        };
      });

      sinon.stub(helper, '_connect').returns({});
      expect(helper.getClient('connect1')).to.be.not.null;
    });

    it('should connect succesfully to the mock database', async () => {
      const obj = {
        user: settingsToValid.user,
        pass: settingsToValid.password,
        replicaSet: settingsToValid.replicaSet,
        ssl: !!settingsToValid.ssl,
        authSource: settingsToValid.authSource,
        useNewUrlParser: true,

        useUnifiedTopology: true
      };
      mongooseMock
        .expects('connect')
        .withArgs(settingsToValid.url, obj)
        .resolves({});

      sinon.stub(mongooseMock.object, 'connection').returns('doneee');

      const algo = await helper._connectSingleConnection(
        JSON.parse(JSON.stringify(settingsToValid))
      );
      expect(algo).to.be.not.null;
      // mongooseMock.verify(); TODO!!!!!
    });

    it('should connect succesfully to the mock database', async () => {
      const obj = {
        user: settingsToValid.user,
        pass: settingsToValid.password,
        replicaSet: settingsToValid.replicaSet,
        ssl: !!settingsToValid.ssl,
        authSource: settingsToValid.authSource,
        useNewUrlParser: true,

        useUnifiedTopology: true
      };
      mongooseMock
        .expects('createConnection')
        .withArgs(settingsToValid.url, obj)
        .resolves({
          on: () => {
            return function() {};
          }
        });
      mongooseMock.object.connection.on = function() {};

      const algo = await helper._connectMultipleConnection(
        JSON.parse(JSON.stringify(settingsToValid))
      );
      expect(algo).to.be.not.null;
    });
  });

  describe('deleting connection name and url', () => {
    it('should delete only urls', () => {
      const arr = [
        { name: 'hola', url: 'localhost.com', connectionName: 'firstConnect' },
        {
          name: 'hola2',
          url: 'http://localhost.com',
          connectionName: 'secondConnect'
        },
        {
          name: 'hola3',
          url: 'localhost.com:3000',
          connectionName: 'thirdConnect'
        }
      ];
      const ans = [
        { name: 'hola', connectionName: 'firstConnect' },
        {
          name: 'hola2',
          connectionName: 'secondConnect'
        },
        {
          name: 'hola3',
          connectionName: 'thirdConnect'
        }
      ];
      expect(helper._deleteParamsFromSettings(arr)).to.eql(ans);
    });
    it('should delete urls and connectionNames', () => {
      const arr = [
        { name: 'hola', url: 'localhost.com', connectionName: 'firstConnect' },
        {
          name: 'hola2',
          url: 'http://localhost.com',
          connectionName: 'secondConnect'
        },
        {
          name: 'hola3',
          url: 'localhost.com:3000',
          connectionName: 'thirdConnect'
        }
      ];
      const ans = [
        { name: 'hola' },
        {
          name: 'hola2'
        },
        {
          name: 'hola3'
        }
      ];
      expect(helper._deleteParamsFromSettings(arr, true)).to.eql(ans);
    });
  });
});
