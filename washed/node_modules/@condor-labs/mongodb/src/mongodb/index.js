'use strict';

const Joi = require('@hapi/joi');
const logger = require('@condor-labs/logger');
const queryString = require('query-string');

const mongoose = require('mongoose');
mongoose.set('useCreateIndex', true);
mongoose.set('useFindAndModify', false);
mongoose.Promise = global.Promise;

const DEFAULT_DB_NAME = '9C62E544E96_UNIQUE_DB_DEFAULT';

const _schemaBasic = {
  host: Joi.string().default('127.0.0.1').required(),
  port: Joi.number().default(27017),
  user: Joi.string().required().allow(''),
  password: Joi.string().required().allow(''),
  database: Joi.string().required(),
  replicaSet: Joi.string(),
  ssl: Joi.boolean().default(false).required(),
  authSource: Joi.string(),
  /** These properties will be removed in the next release (reconnectTries, reconnectInterval) */
  reconnectTries: Joi.number().default(30000), // deprecated: this property is not used.
  reconnectInterval: Joi.number().default(1000), // deprecated: this property is not used.
  readPreference: Joi.string()
    .valid(
      'primary',
      'primaryPreferred',
      'secondary',
      'secondaryPreferred',
      'nearest'
    )
    .default('secondaryPreferred')
};

const self = {
  mongoose,
  _hasMultipleConnection: false,
  _settings: {},
  _clients: {},
  _errorMsgInvalidConectionName: 'INVALID_CONNECTION_NAME',
  _errorMsgInvalidSetting: 'INVALID_SETTINGS',
  _errorMsgUndefinedSetting: 'SETTINGS_NOT_DEFINED',
  _errorNotFoundConnectionName: 'CONNECTION_NAME_DOES_NOT_EXIST',
  _schemaUnique: Joi.object(_schemaBasic),
  _schemaMulti: Joi.array()
    .items(
      Joi.object(
        Object.assign(_schemaBasic, {
          connectionName: Joi.string()
            .uppercase()
            .trim()
            .required()
            .default(DEFAULT_DB_NAME)
        })
      )
    )
    .min(1)
    .unique('connectionName'),
  _validateSettings: (settings) => {
    if (!settings) {
      logger.error(self._errorMsgUndefinedSetting);
      return false;
    }
    try {
      if (Array.isArray(settings)) {
        self._hasMultipleConnection = true;
        settings = self._deleteParamsFromSettings(settings);
        Joi.assert(settings, self._schemaMulti);
      } else {
        settings = self._deleteParamsFromSettings([settings], true);
        Joi.assert(settings[0], self._schemaUnique);
      }

      return true;
    } catch (exception) {
      logger.error(exception);
      throw exception;
    }
  },
  _setSettings: (settings) => {
    if (!self._validateSettings(settings)) {
      throw new Error(self._errorMsgInvalidSetting);
    }

    if (!Array.isArray(settings)) {
      settings.connectionName = DEFAULT_DB_NAME;
      settings = [settings];
    }

    settings.forEach((s) => {
      const hosts = s.host.split(',');
      if (hosts.length > 1 && !s.readPreference) {
        s.readPreference = 'secondaryPreferred';
      }

      const params = queryString.stringify(
        {
          readPreference: s.readPreference
        },
        {
          skipNull: true
        }
      );

      const replicas = hosts.map((url) => `${url}:${s.port}`).join(',');

      s.url = `mongodb://${replicas}/${s.database}?${params}`;
      self._settings[self._trimAndUpperCase(s.connectionName)] = s;
    });
  },
  _connect: async (connectionName = DEFAULT_DB_NAME) => {
    connectionName = self._trimAndUpperCase(connectionName);
    let setting = self._settings[connectionName];

    // $lab:coverage:off$
    if (process.env.NODE_ENV === 'development') {
      /* istanbul ignore next */
      logger.info(`Connecting to ${setting.url}`);
    }

    let connection = null;
    if (self._hasMultipleConnection) {
      connection = await self._connectMultipleConnection(setting);
    } else {
      connection = await self._connectSingleConnection(setting);
    }

    // $lab:coverage:on$
    self._clients[connectionName] = connection;
    return self._isConnected(connectionName);
  },
  _isConnected: (connectionName = DEFAULT_DB_NAME) => {
    connectionName = self._trimAndUpperCase(connectionName);

    if (!self._ifKeyExists(self._settings, connectionName)) {
      throw new Error(self._errorNotFoundConnectionName);
    }

    if (!self._clients[connectionName]) return false;

    if (self._hasMultipleConnection) {
      return self._clients[connectionName]._readyState === 1;
    } else {
      return mongoose.connection.readyState === 1;
    }
  },
  getClient: async (connectionName = DEFAULT_DB_NAME) => {
    connectionName = self._trimAndUpperCase(connectionName);

    if (!self._ifKeyExists(self._settings, connectionName)) {
      throw new Error(self._errorNotFoundConnectionName);
    }

    if (!self._isConnected(connectionName) || !self._clients[connectionName]) {
      // update settings
      self._setSettings(self._settings[connectionName]);
      // Connect
      await self._connect(connectionName);
    }
    return self._clients[connectionName];
  },
  _deleteParamsFromSettings: (setts, deleteConnectionName = false) => {
    setts.forEach((s) => {
      if (s.connectionName && deleteConnectionName) delete s.connectionName;
      if (s.url) delete s.url;
    });
    return setts;
  },
  _trimAndUpperCase: (v) => v.trim().toUpperCase(),
  _ifKeyExists: (obj, key) => obj !== 'undefined' && obj.hasOwnProperty(key),
  _connectMultipleConnection: async (setting) => {
    // $lab:coverage:on$
    const connection = await mongoose.createConnection(setting.url, {
      user: setting.user,
      pass: setting.password,
      replicaSet: setting.replicaSet,
      ssl: !!setting.ssl,
      authSource: setting.authSource,
      // The option `reconnectTries` is incompatible with the unified topology,
      // Please read more by visiting http://bit.ly/2D8WfT6
      // reconnectTries: setting.reconnectTries,
      // reconnectInterval: setting.reconnectInterval,
      useNewUrlParser: true,
      // Unified Topology Design
      // https://mongoosejs.com/docs/deprecations.html#useunifiedtopology
      useUnifiedTopology: true
    });
    // $lab:coverage:off$
    if (process.env.NODE_ENV === 'development') {
      logger.log(`Connected successfully to mongodb`);
    }

    // $lab:coverage:off$
    /* istanbul ignore next */
    if (
      process.env.NODE_ENV === 'development' ||
      process.env.NODE_ENV === 'test'
    ) {
      connection.on('connecting', () => logger.info('Connecting to mongodb'));
      connection.on('connected', function() {
        logger.info(`Mongodb connected ${this.name}`);
      });
      connection.on('disconnecting', () =>
        logger.info('Disconnecting from mongodb')
      );
      connection.on('disconnected', () =>
        logger.info('Disconnected from mongodb')
      );
      connection.on('close', () => logger.info('Mongodb connection closed'));
      connection.on('error', (err) =>
        logger.error('Error Connecting to mongodb', err.message)
      );
      connection.on('reconnected', () =>
        logger.info('Mongodb reconnected successfully')
      );
    }

    return connection;
  },
  _connectSingleConnection: async (setting) => {
    // $lab:coverage:on$
    await mongoose.connect(setting.url, {
      user: setting.user,
      pass: setting.password,
      replicaSet: setting.replicaSet,
      ssl: !!setting.ssl,
      authSource: setting.authSource,
      // The option `reconnectTries` is incompatible with the unified topology,
      // Please read more by visiting http://bit.ly/2D8WfT6
      // reconnectTries: setting.reconnectTries,
      // reconnectInterval: setting.reconnectInterval,
      useNewUrlParser: true,
      // Unified Topology Design
      // https://mongoosejs.com/docs/deprecations.html#useunifiedtopology
      useUnifiedTopology: true
    });
    // $lab:coverage:off$
    /* istanbul ignore next */
    if (process.env.NODE_ENV === 'development') {
      logger.log(`Connected successfully to mongodb`);
    }
    // $lab:coverage:on$
    const connection = mongoose.connection;
    // $lab:coverage:off$
    /* istanbul ignore next */
    if (
      process.env.NODE_ENV === 'development' ||
      process.env.NODE_ENV === 'test'
    ) {
      connection.on('connecting', () => logger.info('Connecting to mongodb'));
      connection.on('disconnecting', () =>
        logger.info('Disconnecting from mongodb')
      );
      connection.on('disconnected', () =>
        logger.info('Disconnected from mongodb')
      );
      connection.on('close', () => logger.info('Mongodb connection closed'));
      connection.on('error', (err) =>
        logger.error('Error Connecting to mongodb', err.message)
      );
      connection.on('reconnected', () =>
        logger.info('Mongodb reconnected successfully')
      );
    }

    return connection;
  }
};

module.exports = self;
